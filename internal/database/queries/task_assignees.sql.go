// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task_assignees.sql

package queries

import (
	"context"
	"database/sql"
)

const assignTaskToUser = `-- name: AssignTaskToUser :one
INSERT INTO task_assignees (
    task_id, user_id
) VALUES (
    ?, ?
)
RETURNING task_id, user_id, assigned_at
`

type AssignTaskToUserParams struct {
	TaskID int64 `json:"task_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) AssignTaskToUser(ctx context.Context, arg AssignTaskToUserParams) (TaskAssignee, error) {
	row := q.db.QueryRowContext(ctx, assignTaskToUser, arg.TaskID, arg.UserID)
	var i TaskAssignee
	err := row.Scan(&i.TaskID, &i.UserID, &i.AssignedAt)
	return i, err
}

const getTaskAssignees = `-- name: GetTaskAssignees :many
SELECT 
    ta.task_id, ta.user_id, ta.assigned_at,
    u.id as user_id,
    u.name as user_name,
    u.email as user_email,
    u.avatar_url as user_avatar_url
FROM task_assignees ta
JOIN users u ON ta.user_id = u.id
WHERE ta.task_id = ?
ORDER BY ta.assigned_at ASC
`

type GetTaskAssigneesRow struct {
	TaskID        int64          `json:"task_id"`
	UserID        int64          `json:"user_id"`
	AssignedAt    sql.NullTime   `json:"assigned_at"`
	UserID_2      int64          `json:"user_id_2"`
	UserName      string         `json:"user_name"`
	UserEmail     string         `json:"user_email"`
	UserAvatarUrl sql.NullString `json:"user_avatar_url"`
}

func (q *Queries) GetTaskAssignees(ctx context.Context, taskID int64) ([]GetTaskAssigneesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskAssignees, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskAssigneesRow
	for rows.Next() {
		var i GetTaskAssigneesRow
		if err := rows.Scan(
			&i.TaskID,
			&i.UserID,
			&i.AssignedAt,
			&i.UserID_2,
			&i.UserName,
			&i.UserEmail,
			&i.UserAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isTaskAssignedToUser = `-- name: IsTaskAssignedToUser :one
SELECT EXISTS(
    SELECT 1 FROM task_assignees
    WHERE task_id = ? AND user_id = ?
) as is_assigned
`

type IsTaskAssignedToUserParams struct {
	TaskID int64 `json:"task_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) IsTaskAssignedToUser(ctx context.Context, arg IsTaskAssignedToUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isTaskAssignedToUser, arg.TaskID, arg.UserID)
	var is_assigned int64
	err := row.Scan(&is_assigned)
	return is_assigned, err
}

const unassignTaskFromUser = `-- name: UnassignTaskFromUser :exec
DELETE FROM task_assignees
WHERE task_id = ? AND user_id = ?
`

type UnassignTaskFromUserParams struct {
	TaskID int64 `json:"task_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) UnassignTaskFromUser(ctx context.Context, arg UnassignTaskFromUserParams) error {
	_, err := q.db.ExecContext(ctx, unassignTaskFromUser, arg.TaskID, arg.UserID)
	return err
}
